---
title: Generic Barrier Base Class
author: Cykada
steamId: '76561198066443130'
date: 09.04.2024
---

## Rundown

Barriers are a classic case of something dota has had introduced without being fully exposed to the modding API, so I've taken it upon myself to create a generic modifier class that can be inherited from in order to streamline barrier creation, and add some extra functionality to barriers in general. 

Unfortunately, this won't add any functionality to any native barriers (Aphotic Shield, Shield Rune, Pipe of Insight, the cheese upgrade no-one cared about a week after the update, etc) since this is for custom barriers.

*Also uses the [Timers](https://github.com/ModDota/TypeScriptAddonTemplate/blob/master/src/vscripts/lib/timers.lua) library to avoid using the modifier's `OnIntervalThink()` function.*
:::info
[Link to the code](https://pastebin.com/M1E2zjku)
:::
 
### Important Info
:::caution
The base class uses some of the default modifier functions, so it's important to use the replacement functions instead!
:::
- `OnCreated()` → `OnBarrierCreated()`
- `OnRefresh()` → `OnBarrierRefresh()`
- `DeclareFunctions()` → `DeclareBonusFunctions()`
- `AddCustomTransmitterData()` → `AddBonusCustomTransmitterData()`

**These 4 functions behave the same as their respective default counterpart, but *must* be used instead, otherwise it will overwrite the base class version.**

There's also some properties that are used in the barrier class that shouldn't be overwritten, but they use `__name` naming so unless you plan on using that, it shouldn't be a problem.

Also worth noting; 
Because there are 3 types of barrier, each one corresponds to a specific damage type.
- `DAMAGE_TYPE_PHYSICAL` is used for physical damage barriers (the red one)
- `DAMAGE_TYPE_MAGICAL` is used for magical damage barriers (the blue one)
- `DAMAGE_TYPE_PURE` is used for all damage barriers (the gold one)

When you set a damage barrier's damage type, make sure to use this list as a reference so you don't declare it incorrectly.

With that out of the way; Here's where the fun stuff begins.


## Added Functions
| Function | Return | Description |
|-------|-------|-------|
| SetBarrierType( [DAMAGE_TYPES](https://moddota.com/api/#!/vscripts/DAMAGE_TYPES) ) | *nil* | Set the barrier to block the specified type of damage. |
| GetBarrierType() | [DAMAGE_TYPES](https://moddota.com/api/#!/vscripts/DAMAGE_TYPES) | Declare / Get what kind of damage the barrier blocks. Physical, Magical, or Pure (all damage). |
| SetBarrierMaxHealth( int ) | *nil* | Set the max health of the barrier. |
| GetBarrierMaxHealth() | int | Declare / Get the max health of the barrier. |
| SetBarrierHealth( int ) | *nil* | Set the current health of the barrier. |
| GetBarrierHealth() | int | Get the current health of the barrier. |
| GetBarrierInitialHealth() | int | Declare / Get the initial health of the barrier. Defaults to `GetBarrierMaxHealth()`. |
| IsBarrier() | bool | Returns true if this modifier is a barrier. |
| IsBarrierFor( [DAMAGE_TYPES](https://moddota.com/api/#!/vscripts/DAMAGE_TYPES) ) | bool | Checks whether the barrier will block the specified type of damage. If you're checking the damage block type, use this function. If you're changing the damage block type, use `SetBarrierType()`. If you're declaring the damage block type, use `GetBarrierType()`. |
| OnBarrierDamagedFilter( event ) | bool | A filter for damage to the barrier. Return false if you want the unit to be damaged instead. Set the `event.damage` to `0` if you want no damage to be done at all. (Only called on server) |
| IsPersistent() | bool | Whether the barrier modifier will persist when the health reaches 0. False by default. |
| ShowOnZeroHP() | bool | Whether the barrier bar is visible at 0 hp. If this is false and the barrier is at 0 hp, `IsBarrier()` will return false. |
| BarrierUpdate() | *nil* | Updates the barrier. Not recommended to be called manually since it should update itself, but if you find a situation where there is a discrepancy then try this. |



## Okay but how do I use it?

I'm glad you asked. 
1. To start off, [grab the code](https://pastebin.com/M1E2zjku) then paste it into a lua file you've put somewhere in your vscripts folder. That is your `modifier_generic_barrier` class file. It's important to remember where you put it, because you'll need to know what the path is.
2. When you create a new modifier you want to be a barrier, make sure to `require("path/modifier_generic_barrier")` so that you have access to the modifier class. You only need to do this once per file, so if you have multiple barrier modifiers in one file then you don't need to require it for each one!
3. Make sure your new modifier inherits the base class by using `modifier_name = class(modifier_generic_barrier)`
4. Declare the barrier's type using `GetBarrierType()`, and it's max health using `GetBarrierMaxHealth()`
5. Enjoy your barrier!


## Indepth example
That's all well and good, but here is a little more indepth example of how to implement it.

Say we're creating a new modifier that we want to be a barrier, at the top of the file we'll have this:
```lua
require("modifier_generic_barrier") -- assuming the file is called 'modifier_generic_barrier' and is just inside the vscripts folder
modifier_new_barrier = class(modifier_generic_barrier) -- our new modifier now inherits from the modifier_generic_barrier class
```

We need to tell the barrier what type of damage it will block, so after that we'll put:
```lua
function modifier_new_barrier:GetBarrierType() 
    return DAMAGE_TYPE_PHYSICAL  -- barrier will block physical damage
end
```

And now we need to tell it how much health the barrier will have:
```lua
function modifier_new_barrier:GetBarrierMaxHealth()
    return self.barrier_hp -- how much health the barrier has
end 
```

But wait a second, we used `self.barrier_hp` which isn't declared yet. So let's quickly do that:
```lua
function modifier_new_barrier:OnBarrierCreated() -- Use the new function!
    self.barrier_hp = self:GetAbility():GetSpecialValueFor("barrier_health")
end
```
Take note of the fact that we used `OnBarrierCreated()` instead of `OnCreated()`, since we didn't want to overwrite the base class' `OnCreated()` function.

Now let's say we want the parent to have some bonus health regen while the barrier is active, so lets declare that real quick;
```lua
function modifier_new_barrier:OnBarrierCreated()
    self.barrier_hp = self:GetAbility():GetSpecialValueFor("barrier_health")

    self.health_regen = self:GetAbility():GetSpecialValueFor("health_regen") -- We can declare properties as usual
end

function modifier_new_barrier:DeclareBonusFunctions() -- Use the new function!
    return {
        MODIFIER_PROPERTY_HEALTH_REGEN_CONSTANT
    }
end

function modifier_new_barrier:GetModifierConstantHealthRegen() 
    return self.health_regen
end
```

So now we have health regen and a barrier, very convenient. But what if we add something else spicy to the mix... what if we want to regenerate mana based on the amount of damage blocked by the barrier? Is that possible? Yes!

Using the `OnBarrierDamageFilter()` function, we can handle any barrier damage instances we want, just as we would normally, and since it's called after the damage is checked but before it goes through, we don't need to do any checks of our own. We just need to add the ratio of damage to mana we want in our created function and we can then use it as we please.
```lua
function modifier_new_barrier:OnBarrierCreated()
    self.barrier_hp = self:GetAbility():GetSpecialValueFor("barrier_health")
    self.health_regen = self:GetAbility():GetSpecialValueFor("health_regen")

    if IsServer() then -- we only need this on the server since our damage filter is server side only
        self.barrier_to_mana = self:GetAbility():GetSpecialValueFor("barrier_to_mana_percent")/100
    end
end

function modifier_new_barrier:OnBarrierDamageFilter( event )
    local mana = event.damage
    
    -- we need to make sure we don't gain more mana than we should if the damage will overkill the barrier
    local current_barrier = self:GetBarrierHealth()
    if current_barrier < event.damage then 
        mana = event.damage - (event.damage - current_barrier)
    end
    
    mana = mana * self.barrier_to_mana
    
    self:GetParent():GiveMana( mana )

    SendOverheadEventMessage(
        nil, -- sendToPlayer
        OVERHEAD_ALERT_MANA_ADD, -- messageType
        self:GetParent(), -- targetEntity 
        mana, -- value
        nil -- sourcePlayer
    )
    
    return true -- Make sure to return true!
end
```

Now we have a physical damage barrier that gives us health regen, and grants us mana based on the damage we take. 
In all, our new modifier file should look something like this:
```lua
require("modifier_generic_barrier")
modifier_new_barrier = class(modifier_generic_barrier)

function modifier_new_barrier:GetBarrierType() 
    return DAMAGE_TYPE_PHYSICAL 
end

function modifier_new_barrier:GetBarrierMaxHealth()
    return self.barrier_hp
end 

function modifier_new_barrier:OnBarrierCreated()
    self.barrier_hp = self:GetAbility():GetSpecialValueFor("barrier_health")
    self.health_regen = self:GetAbility():GetSpecialValueFor("health_regen")

    if IsServer() then
        self.barrier_to_mana = self:GetAbility():GetSpecialValueFor("barrier_to_mana_percent")/100
    end
end

function modifier_new_barrier:DeclareBonusFunctions()
    return {
        MODIFIER_PROPERTY_HEALTH_REGEN_CONSTANT
    }
end

function modifier_new_barrier:GetModifierConstantHealthRegen() 
    return self.health_regen
end

function modifier_new_barrier:OnBarrierDamageFilter( event )
    local mana = event.damage
    
    local current_barrier = self:GetBarrierHealth()
    if current_barrier < event.damage then 
        mana = event.damage - (event.damage - current_barrier)
    end
    
    mana = mana * self.barrier_to_mana
    
    self:GetParent():GiveMana( mana )

    SendOverheadEventMessage(
        nil, -- sendToPlayer
        OVERHEAD_ALERT_MANA_ADD, -- messageType
        self:GetParent(), -- targetEntity 
        mana, -- value
        nil -- sourcePlayer
    )
    
    return true
end
```

There we have it! A completely new barrier modifier using the base class. Pretty simple right? I hope so, that's the whole point of using the base class after all.

:::note
There's a few functions I didn't go over in this guide, but the code has small descriptions for the major ones, and any function that doesn't have a description can be understood from its name.
:::

:::info
[Here's the code again](https://pastebin.com/M1E2zjku)
:::
